[{"name": "app.py", "content": "from pathlib import Path\nfrom zipfile import ZipFile\nfrom htmltools import HTML\nimport numpy as np\nimport pandas as pd\nfrom shiny.express import ui, input, render\nfrom shiny import reactive\nfrom algorithm import ModuleAssigner\nfrom custom_widgets import input_file_area\nfrom data_loading import (\n    check_ranking_and_group_ids_match,\n    check_sufficient_module_spaces,\n    get_formatted_module_data,\n    load_module_assignments,\n    load_module_data,\n    load_module_rankings_data,\n    load_students,\n    validate_module_assignments_data,\n    validate_module_data,\n    validate_module_group_preferences_data,\n    validate_module_rankings_data,\n)\nfrom io import BytesIO\nfrom faicons import icon_svg\n\nAPP_VERSION = \"0.1.4\"\n\nBASE_RANDOM_SEED = 8194761\n\nMAX_SIZE = 50000\nACCEPTED_FILETYPES = [\".csv\"]\n\nmodule_data = reactive.value()\nmodule_dataframe = reactive.value()\nmodule_data_error = reactive.value()\n_ = module_data_error.set(False)\nmodule_groups_data = reactive.value()\nsemesters_data = reactive.value()\n\nrequired_credits_per_student_data = reactive.value()\nmodule_groups_data_mins = reactive.value()\nmodule_groups_data_maxs = reactive.value()\nsemesters_data_mins = reactive.value()\nsemesters_data_maxs = reactive.value()\n\n# If the students request more modules in any group than the total capacity in\n# that group, we have to relax the constraint of assigning students their\n# preferred number of modules per group\nmodule_group_overrequest = reactive.value()\n_ = module_group_overrequest.set(False)\n\nstudent_module_rankings = reactive.value()\nmodule_rankings_error = reactive.value()\n_ = module_rankings_error.set(False)\nstudent_group_preferences = reactive.value()\nstudent_group_preferences_error = reactive.value()\n_ = student_group_preferences_error.set(False)\nstudent_previous_module_allocations = reactive.value()\nstudent_previous_module_allocations_error = reactive.value()\n_ = student_previous_module_allocations_error.set(False)\nstudent_data = reactive.value()\n\nbest_assignment_module_assigner_data = reactive.value()\nbest_assignment_data = reactive.value()\nexcess_module_requests_data = reactive.value()\nmodule_allocation_state_data = reactive.value()\n\n\ndef create_error_modal(message: str):\n    return ui.modal(HTML(message), title=\"Error\", easy_close=True)\n\n\nui.include_css(Path(__file__).parent / \"styles.css\")\nui.head_content(ui.tags.title(f\"Module Allocator {APP_VERSION}\"))\n\n@render.express\ndef _():\n    ui.panel_title(f\"Module Allocator {APP_VERSION}\")\n\n    with ui.navset_underline(id=\"tab\"):\n        # ui.card_header(\"Input Data\")\n        \n        with ui.nav_panel(\n            \"Modules\",\n            icon=(\n                icon_svg(\"check\")\n                if module_data.is_set() and not module_data_error.get() == True\n                else (\n                    icon_svg(\"exclamation\")\n                    if module_data_error.get() == True\n                    else None\n                )\n            ),\n        ):\n                if not module_data.is_set():\n                    input_file_area(\n                        \"modules_file\",\n                        \"Module data file\",\n                        multiple=False,\n                        accept=ACCEPTED_FILETYPES,\n                    )\n                else:\n                    with ui.card():\n                        ui.card_header(\"Module Constraints\")\n\n                        ui.input_action_button(\n                            \"reset_module_data\",\n                            \"Reset Module Data\",\n                            icon=icon_svg(\"trash\"),\n                        )\n\n                        with ui.card():\n                            ui.card_header(\"Required Credits Per Student\")\n                            ui.input_numeric(\n                                \"required_credits_per_student\",\n                                \"Required Credits Per Student\",\n                                1,\n                                min=1,\n                                max=1000,\n                            )\n\n                        with ui.layout_columns(col_widths=[6, 6]):\n                            with ui.card():\n                                ui.card_header(\"Min Credits Per Module Group\")\n                                [\n                                    ui.input_numeric(\n                                        f\"min_credits_module_group_{i}\",\n                                        x,\n                                        1,\n                                        min=1,\n                                        max=1000,\n                                    )\n                                    for i, x in enumerate(module_groups_data())\n                                ]\n                            with ui.card():\n                                ui.card_header(\"Max Credits Per Module Group\")\n                                [\n                                    ui.input_numeric(\n                                        f\"max_credits_module_group_{i}\",\n                                        x,\n                                        1,\n                                        min=1,\n                                        max=1000,\n                                    )\n                                    for i, x in enumerate(module_groups_data())\n                                ]\n\n                        with ui.layout_columns(col_widths=[6, 6]):\n                            with ui.card():\n                                ui.card_header(\"Min Credits Per Semester\")\n                                [\n                                    ui.input_numeric(\n                                        f\"min_credits_semester_{i}\",\n                                        str(x),\n                                        1,\n                                        min=1,\n                                        max=1000,\n                                    )\n                                    for i, x in enumerate(semesters_data())\n                                ]\n                            with ui.card():\n                                ui.card_header(\"Max Credits Per Semester\")\n                                [\n                                    ui.input_numeric(\n                                        f\"max_credits_semester_{i}\",\n                                        str(x),\n                                        1,\n                                        min=1,\n                                        max=1000,\n                                    )\n                                    for i, x in enumerate(semesters_data())\n                                ]\n\n                # with ui.popover():\n                #     icon(\"circle-info\")\n                #     \"Spreadsheet containing module IDs, names, semesters, group names, and capacities\"\n\n        with ui.nav_panel(\n            \"Rankings\",\n            icon=(\n                icon_svg(\"check\")\n                if student_module_rankings.is_set()\n                and not module_rankings_error.get() == True\n                else (\n                    icon_svg(\"exclamation\")\n                    if module_rankings_error.get() == True\n                    else None\n                )\n            ),\n        ):\n\n            if not student_module_rankings.is_set():\n                input_file_area(\n                    \"student_module_rankings_file\",\n                    \"Student module rankings file\",\n                    multiple=False,\n                    accept=ACCEPTED_FILETYPES,\n                )\n            else:\n                with ui.card():\n                    ui.input_action_button(\n                        \"reset_module_rankings_data\",\n                        \"Reset Module Rankings Data\",\n                        icon=icon_svg(\"trash\"),\n                    )\n\n            # with ui.popover():\n            #     icon(\"circle-info\")\n            #     \"Spreadsheet containing student IDs, names, and (for each student) a within-group preference ranking for each module\"\n\n        with ui.nav_panel(\n            \"Group Preferences\",\n            icon=(\n                icon_svg(\"check\")\n                if student_group_preferences.is_set()\n                and not student_group_preferences_error.get() == True\n                else (\n                    icon_svg(\"exclamation\")\n                    if student_group_preferences_error.get() == True\n                    else None\n                )\n            ),\n        ):\n            if not student_group_preferences.is_set():\n                input_file_area(\n                    \"student_group_preferences_file\",\n                    \"Student module group preferences file\",\n                    multiple=False,\n                    accept=ACCEPTED_FILETYPES,\n                )\n            else:\n                with ui.card():\n                    ui.input_action_button(\n                        \"reset_group_preferences_data\",\n                        \"Reset Group Preferences Data\",\n                        icon=icon_svg(\"trash\"),\n                    )\n            # with ui.popover():\n            #     icon(\"circle-info\")\n            #     \"Spreadsheet containing student IDs, names, and (for each student) a preferred number of modules per group\"\n\n        with ui.nav_panel(\n            \"Prior Allocations\",\n            icon=(\n                icon_svg(\"check\")\n                if student_previous_module_allocations.is_set()\n                and not student_previous_module_allocations_error.get() == True\n                else (\n                    icon_svg(\"exclamation\")\n                    if student_previous_module_allocations_error.get() == True\n                    else None\n                )\n            ),\n        ):\n            if not student_previous_module_allocations.is_set():\n                input_file_area(\n                    \"student_previous_module_allocations_file\",\n                    \"Existing student module allocations file (Optional)\",\n                    multiple=False,\n                    accept=ACCEPTED_FILETYPES,\n                )\n            else:\n                with ui.card():\n                    ui.input_action_button(\n                        \"reset_prior_allocations_data\",\n                        \"Reset Prior Allocations Data\",\n                        icon=icon_svg(\"trash\"),\n                    )\n\n            # with ui.popover():\n            #     icon(\"circle-info\")\n            #     \"Spreadsheet containing a student_id column and columns for each module ID, with non-zero entries in columns to which each student (row) has been assigned\"\n\n        ui.nav_spacer()\n\n        with ui.nav_panel(\"Allocation\", icon=icon_svg(\"play\")):\n            with ui.card():\n                ui.card_header(\"Module Assignment Results\")\n                with ui.layout_columns(col_widths=[3, 9]):\n                    with ui.card():\n                        ui.input_numeric(\n                            \"early_stop_number\",\n                            \"Stop After N Modules Per Student\",\n                            3,\n                            min=1,\n                            max=100,\n                        )\n                        ui.input_checkbox(\n                            \"validate_constraints\",\n                            \"Post-check module/credit constraints\",\n                            False,\n                        )\n                        ui.input_numeric(\n                            \"custom_random_seed\",\n                            \"Random Seed\",\n                            BASE_RANDOM_SEED,\n                            min=10000,\n                            max=999999999,\n                        )\n                        ui.input_numeric(\n                            \"assignment_runs\",\n                            \"Random Search Repetitions\",\n                            10,\n                            min=1,\n                            max=250,\n                        )\n                        ui.input_action_button(\"run\", \"Run Assignment\")\n\n                        @render.ui\n                        def download_button():\n                            return (\n                                render.download(\n                                    download, filename=\"assigned_modules.zip\"\n                                )\n                                if best_assignment_module_assigner_data.is_set()\n                                else None\n                            )\n\n                    with ui.card():\n                        with ui.navset_pill(\n                            id=\"module_assignment_results_tabset\"\n                        ):\n                            with ui.nav_panel(\"Assigned Modules\"):\n\n                                @render.data_frame\n                                def assignment_df():\n                                    return render.DataGrid(\n                                        best_assignment_data.get()\n                                    )\n\n                            with ui.nav_panel(\"Over-Requested Modules\"):\n\n                                @render.data_frame\n                                def excess_module_requests_df():\n                                    return render.DataGrid(\n                                        excess_module_requests_data.get()\n                                    )\n\n\ndef load_student_data():\n    student_data.set(None)\n    try:\n\n        missing_from_rankings, missing_from_group_prefs = check_ranking_and_group_ids_match(student_module_rankings.get(), student_group_preferences.get())\n\n        if len(missing_from_rankings) > 0:\n            ui.modal_show(\n                    create_error_modal(\"\\n\".join([f\"<p>Student ID '{str(e)}' is present in the Group Preferences file, but missing from the Rankings file</p>\" for e in missing_from_rankings]))\n                )\n            reset_module_rankings_data()            \n            \n        if len(missing_from_group_prefs) > 0:\n            ui.modal_show(\n                    create_error_modal(\"\\n\".join([f\"<p>Student ID '{str(e)}' is present in the Rankings file, but missing from the Group Preferences file</p>\" for e in missing_from_group_prefs]))\n                )            \n            reset_group_preferences_data()\n        \n        if len(missing_from_rankings) > 0 or len(missing_from_group_prefs) > 0:\n            return\n        \n\n        # Do the students request more modules in a given group than the total capacity of that group?\n        warnings = []\n        module_space_check_results = check_sufficient_module_spaces(module_dataframe.get(), student_group_preferences.get())\n        if len(module_space_check_results) > 0:\n\n            module_group_overrequest.set(True)\n\n            for (group_id, total_requested_spaces, total_available_spaces) in module_space_check_results:\n                if (total_requested_spaces > total_available_spaces):\n                    warnings += [f\"Students requested {total_requested_spaces} module spaces in group '{group_id}', but only {total_available_spaces} are available.\"]\n            warnings += [\"Module allocation may still work, but some students will be assigned fewer modules in these groups than they requested.\"]\n            \n            ui.modal_show(create_error_modal(\"\\n\".join([f\"<p>{w}</p>\" for w in warnings])))\n\n    \n        students, students_missing_ranks, students_missing_ids, missing_modules = (\n            load_students(\n                student_module_rankings.get(),\n                student_group_preferences.get(),\n                module_data.get(),\n            )\n        )\n        student_data.set(students)\n\n        errors = []\n\n        for m in missing_modules:\n            errors += [f\"Module '{m}' is missing from the Rankings file\"]\n\n        for s in students_missing_ranks:\n            errors += [f\"Student with ID '{s}' has module preference rankings missing in the Rankings file\"]\n       \n        if len(errors) > 0:\n            reset_module_rankings_data()            \n            ui.modal_show(create_error_modal(\"\\n\".join([f\"<p>{e}</p>\" for e in errors])))\n            return\n            \n\n    except Exception as e:\n        print(e)\n        ui.modal_show(\n            create_error_modal(\n                \"There was an error loading data from the student module preference files. Please ensure their content is in the correct format and try again.\"\n            )\n        )\n\n\n@reactive.effect\n@reactive.event(input.reset_module_data)\ndef _():\n    module_data.set(None)\n    module_data.unset()\n\n\n@reactive.effect\n@reactive.event(input.reset_group_preferences_data)\ndef _():\n    reset_group_preferences_data()\ndef reset_group_preferences_data():\n    student_group_preferences.set(None)\n    student_group_preferences.unset()\n    student_group_preferences_error.set(False)\n    student_data.unset()\n\n\n@reactive.effect\n@reactive.event(input.reset_module_rankings_data)\ndef _():\n    reset_module_rankings_data()\ndef reset_module_rankings_data():\n    student_module_rankings.set(None)\n    student_module_rankings.unset()\n    module_rankings_error.set(False)\n    student_data.unset()\n\n\n@reactive.effect\n@reactive.event(input.reset_prior_allocations_data)\ndef _():\n    student_previous_module_allocations.set(None)\n    student_previous_module_allocations.unset()\n\n\n@reactive.effect\n@reactive.event(input.modules_file)\ndef file_content():\n    persist_module_allocation_settings()\n    modules_file_info = input.modules_file()[0]\n    if not modules_file_info:\n        return\n\n    try:\n        module_df = load_module_data(Path(modules_file_info[\"datapath\"]))\n        errors = validate_module_data(module_df)\n        if len(errors) > 0:\n            ui.modal_show(\n                create_error_modal(\"\\n\".join([f\"<p>{e}</p>\" for e in errors]))\n            )\n            module_data_error.set(True)\n            return\n        (\n            modules,\n            module_groups,\n            semesters,\n            required_modules_not_found,\n            mutually_excluded_modules_not_found,\n        ) = get_formatted_module_data(module_df)\n        module_dataframe.set(module_df)\n        module_data.set(modules)\n        module_groups_data.set(module_groups)\n        semesters_data.set(semesters)\n        module_data_error.set(False)\n        reload_module_allocation_settings()\n    except Exception as e:\n        print(e)\n        ui.modal_show(\n            create_error_modal(\n                \"There was an error loading data from the module file. Please ensure its content is in the correct format and try again.\"\n            )\n        )\n\n\n@reactive.effect\n@reactive.event(input.student_module_rankings_file)\ndef file_content():\n    persist_module_allocation_settings()\n    student_module_rankings_file_info = input.student_module_rankings_file()[0]\n    if not student_module_rankings_file_info:\n        return\n    try:\n        module_rankings_data = load_module_rankings_data(\n            student_module_rankings_file_info[\"datapath\"]\n        )\n        errors = validate_module_rankings_data(module_rankings_data)\n\n        if len(errors) > 0:\n            ui.modal_show(\n                create_error_modal(\"\\n\".join([f\"<p>{e}</p>\" for e in errors]))\n            )\n            module_rankings_error.set(True)\n            return\n        student_module_rankings.set(module_rankings_data)\n        if student_group_preferences.is_set() and module_data.is_set():\n            load_student_data()\n        module_rankings_error.set(False)\n        reload_module_allocation_settings()\n    except Exception as e:\n        print(e)\n        ui.modal_show(\n            create_error_modal(\n                \"There was an error loading data from the module rankings file. Please ensure its content is in the correct format and try again.\"\n            )\n        )\n\n\n@reactive.effect\n@reactive.event(input.student_group_preferences_file)\ndef file_content():\n    persist_module_allocation_settings()\n    student_group_preferences_file_info = input.student_group_preferences_file()[0]\n    if not student_group_preferences_file_info:\n        return\n    try:\n        student_group_preferences_data = load_module_rankings_data(\n            student_group_preferences_file_info[\"datapath\"]\n        )\n        errors = validate_module_group_preferences_data(student_group_preferences_data)\n\n        if len(errors) > 0:\n            ui.modal_show(\n                create_error_modal(\"\\n\".join([f\"<p>{e}</p>\" for e in errors]))\n            )\n            student_group_preferences_error.set(True)\n            return\n        student_group_preferences.set(student_group_preferences_data)\n        if student_module_rankings.is_set() and module_data.is_set():\n            load_student_data()\n        student_group_preferences_error.set(False)\n        reload_module_allocation_settings()\n    except Exception as e:\n        print(e)\n        ui.modal_show(\n            create_error_modal(\n                \"There was an error loading data from the module group preferences file. Please ensure its content is in the correct format and try again.\"\n            )\n        )\n\n\n@reactive.effect\n@reactive.event(input.student_previous_module_allocations_file)\ndef file_content():\n\n    persist_module_allocation_settings()\n\n    student_previous_module_allocations_file_info = (\n        input.student_previous_module_allocations_file()[0]\n    )\n    if not student_previous_module_allocations_file_info:\n        return\n    try:\n        student_previous_assignments_data = load_module_assignments(\n            student_previous_module_allocations_file_info[\"datapath\"]\n        )\n        errors = validate_module_assignments_data(student_previous_assignments_data)\n\n        if len(errors) > 0:\n            ui.modal_show(\n                create_error_modal(\"\\n\".join([f\"<p>{e}</p>\" for e in errors]))\n            )\n            student_previous_module_allocations_error.set(True)\n            return\n        student_previous_module_allocations.set(student_previous_assignments_data)\n        student_previous_module_allocations_error.set(False)\n        reload_module_allocation_settings()\n    except Exception as e:\n        print(e)\n        ui.modal_show(\n            create_error_modal(\n                \"There was an error loading data from the previous module assignments file. Please ensure its content is in the correct format and try again.\"\n            )\n        )\n\n\n@reactive.effect\n@reactive.event(input.run)\nasync def show_message():\n    module_data_set = module_data.is_set()\n    student_module_rankings_set = student_module_rankings.is_set()\n    student_group_preferences_set = student_group_preferences.is_set()\n\n    m1 = \"\" if module_data_set else \"<li>Module information\"\n    m2 = \"\" if student_module_rankings_set else \"<li>Student module rankings\"\n    m3 = \"\" if student_group_preferences_set else \"<li>Student module group preferences\"\n    message = \"Please provide the following data before running module assignment: <ul>\"\n    for m in [m1, m2, m3]:\n        if m != \"\":\n            message += m\n\n    if (\n        not module_data_set\n        and not student_module_rankings_set\n        and not student_group_preferences_set\n    ):\n        m = ui.modal(\n            HTML(message),\n            easy_close=True,\n            footer=None,\n        )\n        ui.modal_show(m)\n\n    else:\n        assignment_repetitions = input[\"assignment_runs\"].get()\n        best_assignment = None\n\n        loaded_module_assignments = None\n        if student_previous_module_allocations.is_set():\n            loaded_module_assignments = student_previous_module_allocations.get()\n\n        with ui.Progress(min=1, max=assignment_repetitions) as p:\n            for r in range(assignment_repetitions):\n                p.set(\n                    message=\"Running module assignment\",\n                    detail=f\"{r+1} of {assignment_repetitions}\",\n                )\n                best_assignment = run_assignments(\n                    r,\n                    best_assignment,\n                    input[\"early_stop_number\"].get(),\n                    input[\"validate_constraints\"].get(),\n                    loaded_module_assignments,\n                )\n                p.set(r)\n\n        if not best_assignment is None:\n            best_assignment_module_assigner_data.set(best_assignment)\n            best_assignment_data.set(best_assignment.get_all_assigned_modules())\n            excess_module_requests_data.set(\n                best_assignment.get_excess_module_requests().sort_values(\n                    \"excess_requests\", ascending=False\n                )\n            )\n            module_allocation_state_data.set(best_assignment.get_module_dataframe())\n\n        else:\n            ui.notification_show(\n                \"No assignments satisfying the provided constraints were found. Please check the constraints and try again.\",\n                type=\"error\",\n                duration=None,\n            )\n\n\ndef download():\n    if best_assignment_module_assigner_data.is_set():\n        module_assignments: ModuleAssigner = best_assignment_module_assigner_data.get()\n        module_ids, assigned_students_data = (\n            module_assignments.get_assigned_module_students()\n        )\n        zip_file = BytesIO()\n        with ZipFile(zip_file, \"w\") as zf:\n            # Write the csv files containing student IDs assigned to each module\n            for m_idx, m in enumerate(module_ids):\n                b = BytesIO()\n                assigned_students_data[m_idx].to_csv(b, index=False, header=True)\n                zf.writestr(f\"{m}.csv\", b.getvalue())\n\n            # Write the summary of all module assignments for all students to an csv file\n            b_assignment_summary = BytesIO()\n            best_assignment_data.get().to_csv(\n                b_assignment_summary, index=False, header=True\n            )\n            zf.writestr(\n                f\"module_assignment_summary.csv\", b_assignment_summary.getvalue()\n            )\n\n            # Write data on excess module requests to an csv file\n            b_over_requested_modules = BytesIO()\n            excess_module_requests_data.get().to_csv(\n                b_over_requested_modules, index=False, header=True\n            )\n            zf.writestr(\n                f\"excess_module_requests.csv\", b_over_requested_modules.getvalue()\n            )\n\n            # Write the list of modules and associated metadata (including remaining spaces on each module) back to an csv file\n            b_module_allocation_state = BytesIO()\n            module_allocation_state_data.get().to_csv(\n                b_module_allocation_state, index=False, header=True\n            )\n            zf.writestr(f\"module_metadata.csv\", b_module_allocation_state.getvalue())\n\n        yield zip_file.getvalue()\n\n\ndef persist_module_allocation_settings():\n    \"\"\"Store the manually inputted module allocation settings, so that we can restore\n    them when the UI changes.\n    \"\"\"\n    if module_data.is_set():\n        required_credits_per_student_data.set(input.required_credits_per_student.get())\n        module_groups_data_maxs.set([\n                        input[f\"max_credits_module_group_{i}\"].get()\n                        for i, _ in enumerate(module_groups_data())\n                    ])\n        module_groups_data_mins.set([\n                        input[f\"min_credits_module_group_{i}\"].get()\n                        for i, _ in enumerate(module_groups_data())\n                    ])\n        semesters_data_maxs.set([\n                        input[f\"max_credits_semester_{i}\"].get()\n                        for i, _ in enumerate(semesters_data())\n                    ])\n        semesters_data_mins.set([\n                        input[f\"min_credits_semester_{i}\"].get()\n                        for i, _ in enumerate(semesters_data())\n                    ])\n\ndef reload_module_allocation_settings():\n    \"\"\"Insert the stored module allocation settings back into the UI\n    \"\"\"\n    if module_data.is_set():\n        if required_credits_per_student_data.is_set():\n            ui.update_numeric(f\"required_credits_per_student\", value=required_credits_per_student_data.get())\n\n        if module_groups_data_maxs.is_set():\n            for i, _ in enumerate(module_groups_data()):\n                ui.update_numeric(f\"max_credits_module_group_{i}\", value=module_groups_data_maxs.get()[i])\n\n        if module_groups_data_mins.is_set():\n            for i, _ in enumerate(module_groups_data()):\n                ui.update_numeric(f\"min_credits_module_group_{i}\", value=module_groups_data_mins.get()[i])\n\n        if semesters_data_maxs.is_set():\n            for i, _ in enumerate(semesters_data()):\n                ui.update_numeric(f\"max_credits_semester_{i}\", value=semesters_data_maxs.get()[i])\n\n        if semesters_data_mins.is_set():\n            for i, _ in enumerate(semesters_data()):\n                ui.update_numeric(f\"min_credits_semester_{i}\", value=semesters_data_mins.get()[i])\n        \n\n\ndef run_assignments(\n    repetition: int,\n    previous_assignment: ModuleAssigner,\n    halt_after_n_assignments: int,\n    check_constraints: bool,\n    loaded_module_assignments: pd.DataFrame,\n):\n    print(f\"Running {repetition}\")\n    successful_assignments = []\n    successful_assignment_mean_scores = []\n    successful_assignment_median_scores = []\n\n    module_assigner = ModuleAssigner(\n        student_data.get(),\n        module_data.get(),\n        input.required_credits_per_student.get(),\n        dict(\n            zip(\n                module_groups_data.get(),\n                [\n                    input[f\"max_credits_module_group_{i}\"].get()\n                    for i, _ in enumerate(module_groups_data())\n                ],\n            )\n        ),\n        dict(\n            zip(\n                semesters_data.get(),\n                [\n                    input[f\"max_credits_semester_{i}\"].get()\n                    for i, _ in enumerate(semesters_data())\n                ],\n            )\n        ),\n        dict(\n            zip(\n                module_groups_data.get(),\n                [\n                    input[f\"min_credits_module_group_{i}\"].get()\n                    for i, _ in enumerate(module_groups_data())\n                ],\n            )\n        ),\n        dict(\n            zip(\n                semesters_data.get(),\n                [\n                    input[f\"min_credits_semester_{i}\"].get()\n                    for i, _ in enumerate(semesters_data())\n                ],\n            )\n        ),\n        input[\"custom_random_seed\"].get() + repetition * input[\"custom_random_seed\"].get() + 1,\n    )\n\n    print(f\"Module assigner seed: {module_assigner._random_seed}\")\n\n    print(\"Loading pre-existing module assignments\")\n    if not loaded_module_assignments is None:\n        module_assigner.set_loaded_module_assignments(loaded_module_assignments)\n\n    result_messages = []\n    for i in range(halt_after_n_assignments):\n        result_messages = module_assigner.run_assignment_round()\n\n    semester_minimum_satisfied = np.all(\n        module_assigner.assignment_satisfies_minimum_credits_per_semester()\n    )\n    group_minimum_satisfied = np.all(\n        module_assigner.assignment_satisfies_minimum_credits_per_group()\n    )\n    credit_total_satisfied = np.all(\n        module_assigner.get_assigned_credits_totals()\n        == module_assigner._required_credits_per_student\n    )\n    module_total_satisfied = np.all(\n        module_assigner.get_assigned_modules_totals()\n        == halt_after_n_assignments\n    )\n\n    print(module_assigner.get_assigned_modules_totals())\n\n    if (\n        semester_minimum_satisfied\n        and group_minimum_satisfied\n        and credit_total_satisfied\n        and module_total_satisfied\n    ) or (not check_constraints and module_total_satisfied):\n        successful_assignments.append(module_assigner)\n\n    best_assignment = previous_assignment\n    if len(successful_assignments) > 0:\n        if best_assignment is None:\n            best_assignment = successful_assignments[0]\n        else:\n            previous_scores = best_assignment.get_assignment_satisfaction_scores()\n            current_scores = successful_assignments[\n                0\n            ].get_assignment_satisfaction_scores()\n\n            previous_overallocation = best_assignment.get_excess_module_requests()\n            current_overallocation = successful_assignments[\n                0\n            ].get_excess_module_requests()\n\n            previous_overallocation_mean = previous_overallocation[\"proportion_overrequested\"].mean()\n            current_overallocation_mean = current_overallocation[\"proportion_overrequested\"].mean()\n\n            previous_mean_score = np.nanmean(previous_scores)\n            current_mean_score = np.nanmean(current_scores)\n\n            best_assignment = (\n                successful_assignments[0]\n                if (current_mean_score >= previous_mean_score)\n                else best_assignment\n            )\n            if (current_mean_score >= previous_mean_score) and (current_overallocation_mean <= previous_overallocation_mean):\n                best_assignment = successful_assignments[0]\n                print(f\"Updated best assignment {repetition} {previous_mean_score} {current_mean_score}\")\n            \n    return best_assignment\n", "type": "text"}, {"name": "algorithm.py", "content": "from typing import Self\nimport numpy as np\nimport pandas as pd\nimport copy\n\nclass Module:    \n    def __init__(self, module_id:str, module_name:str, credits:int, semester:int, group:str, total_spaces:int, available_spaces:int, mutual_exclusions:list[Self], requirements:list[Self]) -> None:\n        self.module_id = module_id\n        self.module_name = module_name\n        self.credits = credits\n        self.semester = semester\n        self.group = group\n        self.total_spaces = total_spaces\n        self.available_spaces = available_spaces\n        self.mutual_exclusions = mutual_exclusions\n        self.requirements = requirements\n\n    def __repr__(self) -> str:\n        return f\"Module: {self.module_id} | Cr:{self.credits} | S:{self.semester} | G:{self.group}\"\n    \n    def add_mutual_exclusions(self, mutual_exclusions:list[Self]):\n        self.mutual_exclusions = list(set(self.mutual_exclusions).union(mutual_exclusions))\n        for module in mutual_exclusions:\n            if self not in module.mutual_exclusions:\n                module.add_mutual_exclusions([self])\n\n    def add_requirements(self, requirements:list[Self]):\n        self.requirements = list(set(self.requirements).union(requirements))\n\nclass Student:\n    def __init__(self, name:str, id:str, preferred_modules_per_group:dict[str, int], module_rankings:dict[str, int], excluded_modules:list[str]):\n        self.name = name\n        self.id = id\n        self.module_rankings_by_id = module_rankings\n        self.preferred_modules_per_group = preferred_modules_per_group\n        self.excluded_modules_by_id = excluded_modules\n\n    def __repr__(self) -> str:\n        return f\"{self.name}\"\n\n\n\n#TODO: What object should keep tract of remaining spaces on each module? Probably the assigner rather than the module objects (which can be shared between assigners)\nclass ModuleAssigner:\n    def __init__(self, students:list[Student], modules:list[Module], required_credits_per_student:int, max_credits_per_group:dict[str, int], max_credits_per_semester:dict[str, int], min_credits_per_group:dict[str, int], min_credits_per_semester:dict[str, int], random_seed:int):\n        self._n_students = len(students)\n        self._students = copy.deepcopy(students)\n        self._student_ids = [s.id for s in self._students]\n        self._modules = copy.deepcopy(modules)\n        self._required_credits_per_student = required_credits_per_student\n        self._unique_module_groups = list(set([m.group for m in self._modules]))\n        self._unique_semesters = list(set([m.semester for m in self._modules]))\n        self._grouped_modules = [[m for m in self._modules if m.group == group_label] for group_label in self._unique_module_groups]\n        self._student_module_grouped_preferences = [np.array([[s.module_rankings_by_id[m.module_id] for m in module_group] for s in self._students]) for module_group in self._grouped_modules]\n        self._student_module_group_credit_preferences = np.array([[s.preferred_modules_per_group[g] for g in self._unique_module_groups] for s in self._students])\n        self._max_credits_per_group = [max_credits_per_group[g_id] for g_id in self._unique_module_groups]\n        self._max_credits_per_semester = [max_credits_per_semester[i] for i in self._unique_semesters]\n        self._min_credits_per_group = [min_credits_per_group[g_id] for g_id in self._unique_module_groups]\n        self._min_credits_per_semester = [min_credits_per_semester[i] for i in self._unique_semesters]\n\n        # list of N groups 2d arrays (one row per student, one column per module) containing assignments of students to each module in each group\n        # TODO: Make it possible to load in how may credits the student has already been assigned\n        self._student_assigned_credits = [np.zeros((len(self._students), len(self._grouped_modules[i])), dtype=np.int16) for i in range(len(self._unique_module_groups))]\n\n        # Spaces remaining on each module\n        #self._module_spaces_remaining = dict(zip(self._modules, map(lambda m: m.available_spaces, self._modules)))\n\n        # Number of times the algorithm attempted to assign a student to each module\n        self._module_spaces_excess_requests = dict(zip(self._modules, [0 for _ in range(len(self._modules))]))\n\n        # Random state for choosing student permutations\n        self._random_seed = random_seed\n        self._rs = np.random.RandomState(random_seed)\n\n    def set_loaded_module_assignments(self, data:pd.DataFrame):\n        \"\"\"Load the previously assigned modules for each student\n        from the given dataframe\n\n        Args:\n            data (pd.DataFrame): A data frame containing a column of student IDs, and columns for each module, where a non-zero entry in the latter columns indicates that the student was assigned to that module\n        \"\"\"\n\n        for s_idx, s in enumerate(self._students):\n            student_data = data[(data.student_id == s.id)]\n            for mg_idx, mg in enumerate(self._grouped_modules):\n                for m_idx, m in enumerate(mg):\n                    if student_data[m.module_id].values[0] > 0:\n                        self._student_assigned_credits[mg_idx][s_idx][m_idx] = m.credits\n\n\n\n    def get_module_dataframe(self):\n        \"\"\"Get a Pandas DataFrame containing the module metadata (ids, names, capacity, etc),\n        and the number of unallocated spaces remaining on each module.\n\n        Returns:\n            pd.DataFrame: The module metadata\n        \"\"\"\n        data = dict()\n        data[\"module_id\"] = []\n        data[\"module_name\"] = []\n        data[\"module_group\"] = []\n        data[\"semester\"] = []\n        data[\"credits\"] = []\n        data[\"capacity\"] = []\n        data[\"available_spaces\"] = []\n        data[\"required_modules\"] = []\n        data[\"mutually_excluded_modules\"] = []\n\n        for module in self._modules:\n            data[\"module_id\"] += [module.module_id]\n            data[\"module_name\"] += [module.module_name]\n            data[\"module_group\"] += [module.group]\n            data[\"semester\"] += [module.semester]\n            data[\"credits\"] += [module.credits]\n            data[\"capacity\"] += [module.total_spaces]\n            data[\"available_spaces\"] += [module.available_spaces]\n            data[\"required_modules\"] += [\",\".join([m.module_id for m in module.requirements])]\n            data[\"mutually_excluded_modules\"] += [\",\".join([m.module_id for m in module.mutual_exclusions])]\n\n        return pd.DataFrame(data)\n\n    def get_assigned_credits_totals(self):\n        \"\"\"Get the total number of credits assigned to each student\n\n        Returns:\n            np.ndarray: An array of integers representing the total numbers of credits assigned to each student\n        \"\"\"\n        return np.sum(np.array(list(map(lambda a: np.sum(a, axis=1), self._student_assigned_credits))).T, axis=1)\n\n\n    def get_assigned_modules_totals(self):\n        \"\"\"Get the total number of modules assigned to each student\n\n        Returns:\n            np.ndarray: An array of integers representing the total numbers of modules assigned to each student\n        \"\"\"\n        return np.sum(np.array(list(map(lambda a: np.sum(a != 0, axis=1), self._student_assigned_credits))).T, axis=1)\n    \n\n    def get_assigned_modules(self, selected_student_id:str):\n        \"\"\"Get a list of the Module objects which have been assigned to\n        the student with the given ID\n\n        Args:\n            selected_student_id (str): ID of the student whose assigned modules to return\n\n        Returns:\n            List[Module]: A list of references to the modules assigned to the given student\n        \"\"\"\n        s_idx = self._student_ids.index(selected_student_id)\n        assigned_modules:list[Module] = []\n        for g_idx, group in enumerate(self._student_assigned_credits):\n            for m_idx in np.nonzero(group[s_idx])[0]:\n                assigned_modules += [self._grouped_modules[g_idx][m_idx]]\n        return assigned_modules\n    \n    def get_all_assigned_modules(self):\n        student_names = [s.name for s in self._students]\n        student_ids = [s.id for s in self._students]\n\n        names_ids_df = pd.DataFrame({\"student_name\":student_names, \"student_id\":student_ids})\n        student_module_group_preferences_df = pd.DataFrame([s.preferred_modules_per_group for s in self._students])\n        module_allocations_df = pd.DataFrame(columns=[m.module_id for m in self._modules])        \n        \n        for s_idx, s in enumerate(self._students):\n            assigned_modules = self.get_assigned_modules(s.id)\n            new_row = {m.module_id: s.module_rankings_by_id[m.module_id] if m in assigned_modules else 0 for m in self._modules}\n            module_allocations_df.loc[s_idx] = new_row\n\n        return pd.concat([names_ids_df, student_module_group_preferences_df, module_allocations_df], axis=1)\n    \n    def get_assigned_module_students(self):\n        module_ids = []\n        assigned_student_dfs = []\n        for m in self._modules:\n            students_for_current_module:list[Student] = []\n            for s in self._students:\n                assigned_modules = self.get_assigned_modules(s.id)\n                if m in assigned_modules:\n                    students_for_current_module.append(s)\n            \n            df = pd.DataFrame({\"student_name\":[s.name for s in students_for_current_module], \"student_id\":[s.id for s in students_for_current_module]})\n            module_ids.append(m.module_id)\n            assigned_student_dfs.append(df)\n\n        return module_ids, assigned_student_dfs\n\n    def get_assignment_satisfaction_scores(self):\n        \"\"\"Get the per-participant, per-module-group satisfaction scores.\n        The satisfaction score is a number in the range [0, 1], where 1\n        corresponds to the case where the student has been assigned their\n        most preferred modules in that group and 0 corresponds to the \n        case where they have been assigned their least preferred modules.\n        The students' stated preferences for numbers of modules per\n        group are not accounted for by this measure.\n\n        Returns:\n            np.ndarray: An array of shape (# students, # module groups) containing satisfaction scores\n        \"\"\"\n        modules_per_group = np.zeros(len(self._unique_module_groups))\n        for m in self._modules:\n            g_idx = self._unique_module_groups.index(m.group)\n            modules_per_group[g_idx] += 1\n\n        scores = []\n        best = []\n        worst = []\n        for s in self._students:\n            per_group_assignment_counts = np.zeros(len(self._unique_module_groups))\n            ideal_per_group_pref_scores = np.zeros(len(self._unique_module_groups))\n            worst_per_group_pref_scores = np.zeros(len(self._unique_module_groups))\n            per_group_pref_scores = np.zeros(len(self._unique_module_groups))\n            assigned_modules = self.get_assigned_modules(s.id)\n\n            for m in assigned_modules:\n                g_idx = self._unique_module_groups.index(m.group)\n                per_group_pref_scores[g_idx] += s.module_rankings_by_id[m.module_id]\n                per_group_assignment_counts[g_idx] += 1\n\n            for g_id in self._unique_module_groups:\n                g_idx = self._unique_module_groups.index(g_id)\n                ideal_per_group_pref_scores[g_idx] = np.sum(np.arange(per_group_assignment_counts[g_idx]) + 1)\n                worst_per_group_pref_scores[g_idx] = np.sum(np.arange(modules_per_group[g_idx] - per_group_assignment_counts[g_idx], modules_per_group[g_idx]) + 1)\n\n            scores += [per_group_pref_scores]\n            best += [ideal_per_group_pref_scores]\n            worst += [worst_per_group_pref_scores]      \n\n        return 1 - ((np.stack(scores) - np.stack(best)) / (np.stack(worst) - np.stack(best)))\n\n    def get_excess_module_requests(self):\n        module_ids = [m.module_id for m in self._modules]\n        module_names = [m.module_name for m in self._modules]\n        excess_requests = [self._module_spaces_excess_requests[m] for m in self._modules]\n        proportion_overrequested = [self._module_spaces_excess_requests[m] / m.total_spaces for m in self._modules]\n        return pd.DataFrame({\"module_id\":module_ids, \"module_name\":module_names, \"excess_requests\":excess_requests, \"proportion_overrequested\":proportion_overrequested})\n\n    def assignment_satisfies_minimum_credits_per_group(self):\n        \"\"\"\n        Returns:\n            boolean: True iff the assignment of students to modules meets the minimum number of credits per module group for all students\n        \"\"\"\n        return np.array(list(map(lambda a: np.sum(a, axis=1), self._student_assigned_credits))).T >= self._min_credits_per_group\n    \n    def assignment_satisfies_minimum_credits_per_semester(self):\n        \"\"\"        \n        Returns:\n            boolean: True iff the assignment of students to modules meets the minimum number of credits per semester for all students\n        \"\"\"\n        credits_per_semester = np.stack([np.sum(np.stack([np.sum(np.stack([self._student_assigned_credits[g_idx][:, m_idx] for m_idx, m in enumerate(g) if m.semester == s]), axis=0) for g_idx, g in enumerate(self._grouped_modules)]), axis=0) for s in self._unique_semesters]).T\n        return credits_per_semester >= self._min_credits_per_semester\n\n    def log(self, message):\n        print(message)\n\n    def run_assignment_round(self):\n        \n\n        \"\"\"Run one round of the assignment algorithm.\n        This may assign more than one module to each participant, if \n        the module to be assigned has other modules as requirements.\n        If there are no modules available which satisfy the constraints\n        for a given student then no module will be assigned to them.\n\n        Returns:\n            List[dict[str, boolean]]: A list of dictionaries giving \n            information about constraints that were not satisfied while \n            trying to assign a module to each participant.\n        \"\"\"\n\n        # How many credits has each student been assigned in each module group\n        assigned_credits_total = np.array(list(map(lambda a: np.sum(a, axis=1), self._student_assigned_credits))).T\n\n        # Which module group is furthest from satisfying the students' preferred number of credits for that group\n        next_assignment_group_idxs = np.argsort(assigned_credits_total - self._student_module_group_credit_preferences, axis=1)\n       \n        # Select a random order in which to let students \"pick\" a module\n        choice_order = self._rs.permutation(self._n_students)\n        \n        # self.log(assigned_credits_total)\n        # self.log(\"|||||\")\n\n        # Keep track of which modules each student has already \"requested\" during allocation\n        requested_modules = dict(zip(self._students, [[] for _ in self._students]))\n\n        result_trace = []\n        # For each participant in a random order\n        for student_idx in choice_order:\n            considered_modules = []\n            # If the current student has not got enough assigned module credits yet...\n            if np.sum(assigned_credits_total[student_idx]) < self._required_credits_per_student:\n\n                modules_assigned = False\n\n                # We may need to relax the constraint of not assigning students modules they preferentially request not to be assigned\n                for allow_preferentially_exclude_modules in [False, True]:\n                    \n                    # We may need to relax the maximum credits per group requirement\n                    for allow_excess_credits_per_group in [False, True]:\n\n                        # We may need to relax the constraint of not assigning students their least preferred modules in each group\n                        for allow_least_preferred_modules in [False, True]:\n                            # Select the group of modules needing a new assignment for this participant.\n                            # If we can't allocate a module in the preferred group, try the next most preferred group.\n                            for group_idx in next_assignment_group_idxs[student_idx]:\n\n                                if not modules_assigned:\n\n                                    # The module preference rankings of the current student for the current module group \n                                    current_student_group_module_prefs = self._student_module_grouped_preferences[group_idx][student_idx]\n\n                                    # For each module in descending order of preference (i.e. increasing preference value)...\n                                    for module_idx in np.argsort(current_student_group_module_prefs):\n\n                                        student_assigned_modules:list[Module] = self.get_assigned_modules(self._student_ids[student_idx])\n\n                                        student_assigned_credits_per_semester = np.zeros(len(self._max_credits_per_semester))\n                                        for m in student_assigned_modules:                       \n                                            student_assigned_credits_per_semester[self._unique_semesters.index(m.semester)] += m.credits\n\n                                        # Select this student's most preferred module in the current module group\n                                        module:Module = self._grouped_modules[group_idx][module_idx]\n\n                                        considered_modules += [module]\n                                        \n                                        # Select the module and its requirements that have not yet been assigned to this student\n                                        modules_to_assign = set(module.requirements + [module]).difference(student_assigned_modules)\n\n                                        if len(modules_to_assign) > 0:                    \n\n                                            requested_credits_per_group = np.zeros(len(self._max_credits_per_group))\n                                            for m in modules_to_assign:\n                                                requested_credits_per_group[self._unique_module_groups.index(m.group)] += m.credits\n\n                                            requested_credits_per_semester = np.zeros(len(self._max_credits_per_semester))\n                                            for m in modules_to_assign:                       \n                                                requested_credits_per_semester[self._unique_semesters.index(m.semester)] += m.credits\n                                            \n                                            # If both the selected module and its requirements have space remaining for new students...\n                                            modules_have_space_remaining = np.all([m.available_spaces > 0 for m in modules_to_assign])\n                                            \n                                            # If neither the selected module nor its requirements are mutually excluded by already assigned modules...                \n                                            current_student_mutual_exclusions = [ex_m for m in student_assigned_modules for ex_m in m.mutual_exclusions]\n                                            modules_not_excluded = set(modules_to_assign).isdisjoint(current_student_mutual_exclusions)\n\n                                            # If the selected module and its requirements are not in the list of modules specifically excluded by this student...\n                                            modules_not_excluded_by_student = set(map(lambda m: m.module_id, modules_to_assign)).isdisjoint(self._students[student_idx].excluded_modules_by_id) if not allow_preferentially_exclude_modules else True\n\n                                            # If the selected module and its requirements will not give the student too many credits in each group...\n                                            requested_credits_not_too_many_per_group = np.all(assigned_credits_total[student_idx] + requested_credits_per_group <= self._max_credits_per_group) if not allow_excess_credits_per_group else True\n\n                                            # If the selected module and its requirements will not give the student too many credits in total, across all groups...\n                                            requested_credits_not_too_many_total = np.sum(assigned_credits_total[student_idx] + requested_credits_per_group) <= self._required_credits_per_student\n\n                                            # If the selected module and its requirements will not give the student too many credits in one semester...\n                                            requested_credits_per_semester_not_too_many = np.all(student_assigned_credits_per_semester + requested_credits_per_semester <= self._max_credits_per_semester)\n\n                                            # If one of the selected modules has the lowest possible preference (i.e. largest preference rating) in its module group\n                                            least_preferred_module_selected = np.any([current_student_group_module_prefs[self._grouped_modules[group_idx].index(m)] == np.max(current_student_group_module_prefs) for m in modules_to_assign])\n                                            preferences_okay = (not least_preferred_module_selected) or (least_preferred_module_selected and allow_least_preferred_modules)            \n\n                                            # Keep track of how many excess requests (beyond module capacity) each module had during allocation, counting each student only once\n                                            if not modules_have_space_remaining:\n                                                if not m in requested_modules[self._students[student_idx]]:\n                                                    self._module_spaces_excess_requests[m] = self._module_spaces_excess_requests[m] + 1\n                                                    requested_modules[self._students[student_idx]] = requested_modules[self._students[student_idx]] + [m]\n\n                                            # if not modules_have_space_remaining:\n                                            #     self.log(\"Assignment pass failed: Requested modules have no spaces remaining\")\n                                            #     continue\n\n                                            # if not modules_not_excluded:\n                                            #     self.log(\"Assignment pass failed: Mutually excluded modules were requested\")\n                                            #     continue\n\n                                            # if not modules_not_excluded_by_student:\n                                            #     self.log(\"Assignment pass failed: Student excluded modules were requested\")\n                                            #     continue\n\n                                            # if not requested_credits_not_too_many_per_group:\n                                            #     self.log(\"Assignment pass failed: Requested modules exceeded per group credit maximum\")\n                                            #     continue\n\n                                            # if not requested_credits_not_too_many_total:\n                                            #     self.log(\"Assignment pass failed: Requested modules exceeded total credit maximum\")\n                                            #     continue\n\n                                            # if not requested_credits_per_semester_not_too_many:\n                                            #     self.log(\"Assignment pass failed: Requested modules exceeded per semester credit maximum\")\n                                            #     continue\n\n                                            # if not preferences_okay:\n                                            #     self.log(\"Assignment pass failed: Requested modules included lowest-ranked module for the current student\")\n                                            #     continue\n\n\n                                            # Assign the module and its requirements to the student\n                                            if modules_have_space_remaining and modules_not_excluded and modules_not_excluded_by_student and requested_credits_not_too_many_per_group and requested_credits_not_too_many_total and requested_credits_per_semester_not_too_many and preferences_okay:\n                                                for m in modules_to_assign:\n                                                    g_idx = self._unique_module_groups.index(m.group)\n                                                    m_idx = self._grouped_modules[g_idx].index(m)                                    \n                                                    self._student_assigned_credits[g_idx][student_idx][m_idx] = m.credits\n                                                    m.available_spaces -= 1\n                                                    #self._module_spaces_remaining[m] = self._module_spaces_remaining[m] - 1\n                                                    #self._modules[self._modules.index(m)].available_spaces -= 1\n                                                    assigned_credits_total[student_idx][g_idx] += m.credits\n                                                    modules_assigned = True\n                                                    if(m.available_spaces < 0):\n                                                        print(m)\n                                                break\n                                    \n                    if modules_assigned:\n                        break\n                    \n                if not modules_assigned:\n                    result_trace += [dict(zip([\"student_id\",\n                                              \"modules_have_space_remaining\", \n                                              \"modules_not_excluded\", \n                                              \"requested_credits_not_too_many_per_group\", \n                                              \"requested_credits_not_too_many_total\", \n                                              \"requested_credits_per_semester_not_too_many\",\n                                              \"preferences_okay\"],\n                                             [self._student_ids[student_idx],\n                                             modules_have_space_remaining, \n                                             modules_not_excluded, \n                                             requested_credits_not_too_many_per_group, \n                                             requested_credits_not_too_many_total, \n                                             requested_credits_per_semester_not_too_many,\n                                             preferences_okay]))]\n            #print(len(set(considered_modules)), set(considered_modules))\n\n        return result_trace", "type": "text"}, {"name": "custom_widgets.py", "content": "from pathlib import Path\nfrom typing import Literal, Optional\nfrom htmltools import Tag, TagChild, css, div, span, tags\nfrom shiny._namespaces import resolve_id\nfrom shiny.ui._utils import shiny_input_label\nfrom faicons import icon_svg\n\ndef input_file_area(\n    id: str,\n    label: TagChild,\n    *,\n    multiple: bool = False,\n    accept: Optional[str | list[str]] = None,\n    width: Optional[str] = None,\n    button_label: str = \"Browse...\",\n    placeholder: str = \"No file selected\",\n    capture: Optional[Literal[\"environment\", \"user\"]] = None,\n) -> Tag:\n    \"\"\"\n    Create a file upload control that can be used to upload one or more files.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    multiple\n        Whether the user should be allowed to select and upload multiple files at once.\n    accept\n        Unique file type specifier(s) which give the browser a hint as to the type of\n        file the server expects. Many browsers use this to prevent the user from\n        selecting an invalid file. Examples of valid values include a case insensitive\n        extension (e.g. ``.csv`` or ``.rds``), a valid MIME type (e.g. ``text/plain`` or\n        ``application/pdf``) or one of ``audio/*``, ``video/*``, or ``image/*`` meaning\n        any audio, video, or image type, respectively.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    button_label\n        The label used on the button.\n    placeholder\n        The text to show on the input before a file has been uploaded.\n    capture\n        On mobile devices, this can be used to open the device's camera for input. If\n        \"environment\", it will open the rear-facing camera. If \"user\", it will open the\n        front-facing camera. By default, it will accept either still photos or video. To\n        accept only still photos, use ``accept=\"image/*\"``; to accept only video, use\n        ``accept=\"video/*\"``.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    -----\n\n    ::: {.callout-note title=\"Server value\"}\n    A list of dictionaries (one for each file upload) with the following keys:\n\n    * ``name``: The filename provided by the web browser. This is *not* the path to read\n        to get at the actual data that was uploaded (see 'datapath').\n    * ``size``: The size of the uploaded data, in bytes.\n    * ``type``: The MIME type reported by the browser (for example, 'text/plain'), or\n        empty string if the browser didn't know.\n    * ``datapath``: The path to a temp file that contains the data that was uploaded.\n        This file may be deleted if the user performs another upload operation.\n    :::\n\n    See Also\n    --------\n    * :func:`~shiny.ui.download_button`\n    \"\"\"\n\n    if isinstance(accept, str):\n        accept = [accept]\n\n    resolved_id = resolve_id(id)\n    btn_file = span(\n        tags.input(\n            id=resolved_id,\n            name=resolved_id,\n            type=\"file\",\n            multiple=\"multiple\" if multiple else None,\n            accept=\",\".join(accept) if accept else None,\n            capture=capture,\n            # Don't use \"display: none;\" style, which causes keyboard accessibility issue; instead use the following workaround: https://css-tricks.com/places-its-tempting-to-use-display-none-but-dont/\n            style=\"position: absolute !important; top: -99999px !important; left: -99999px !important;\",\n            class_=\"shiny-input-file\",\n        ),\n    )\n    return div(\n        # shiny_input_label(resolved_id, label),\n        div(\n            tags.label(\n                btn_file,\n                div(\n                    # tags.input(\n                    #     type=\"text\",\n                    #     class_=\"form-control\",\n                    #     placeholder=placeholder,\n                    #     readonly=\"readonly\",\n                    # ),\n                    span(icon_svg(\"upload\"), class_=\"upload_icon\"),\n                    div(\n                        (label),\n                        style=\"font-size: 1rem; font-weight: 500; margin:10px\",\n                    ),\n                    div(\n                        div(class_=\"progress-bar\"),\n                        id=resolved_id + \"_progress\",\n                        class_=\"progress active shiny-file-input-progress\", style=\"margin:10px\",\n                    ),\n                    class_=\"upload-button flex\",\n                ),\n                class_=\"input-group-btn input-group-prepend\",\n            ),\n            class_=\"input-group\",\n        ),\n        style=css(width=width),\n    )\n", "type": "text"}, {"name": "data_loading.py", "content": "from pathlib import Path\nimport numpy as np\nimport pandas as pd\n\nfrom algorithm import Module, ModuleAssigner, Student\n\n\n\n# Check if any item in any row contains the replacement character\ndef check_for_replacement_char(row):\n    replacement_char = u'\\ufffd'\n    for idx, cell in enumerate(row):\n        if replacement_char in str(cell):\n            return True, idx\n    return False, None\n\ndef find_replacement_character_indices(df:pd.DataFrame):\n    rows_with_replacement_char = df.apply(lambda row: check_for_replacement_char(row), axis=1)\n    rows_with_replacement_char_info = [(row_num, col_num) for row_num, (found, col_num) in enumerate(rows_with_replacement_char) if found]\n    return rows_with_replacement_char_info\n\ndef get_replacement_character_error_messages(df:pd.DataFrame):\n    errors = []\n    replacement_character_indices = find_replacement_character_indices(df)\n    if len(replacement_character_indices) > 0:\n        errors += [\"Unrecognised characters were found in this data file. Please edit the file to remove these characters and try again.\"]\n    for r, c in replacement_character_indices:\n        errors += [f\"The item in row {r+1}, column {c+1} contains unrecognised characters: '{df.iloc[r, c]}'\"]\n    return errors\n\n\ndef validate_module_data(data:pd.DataFrame):\n    errors = []\n    required_columns = [\"module_id\", \"module_name\", \"module_group\", \"semester\", \"credits\", \"capacity\", \"available_spaces\", \"required_modules\", \"mutually_excluded_modules\"]\n    for c in required_columns:\n        if not c in data.columns:\n            errors += [f\"Column '{c}' was not found in the module data file\"]\n\n    errors += get_replacement_character_error_messages(data)\n\n    return errors \n\ndef load_module_data(filepath:Path):\n    \"\"\"Load the module data from a given csv file\n\n    Args:\n        filepath (Path): Path to the csv file containing module data\n\n    Returns:\n        (list[Module], list[str], list[str], set, set): A list of loaded \n        modules, a list of module group names, a list of semester IDs, a \n        set containing the IDs of any required modules not found in the \n        loaded modules list, a set containing the IDs of any mutually \n        excluded modules not found in the loaded modules list\n    \"\"\"\n    module_data = pd.read_csv(filepath, encoding=\"utf-8\", encoding_errors=\"replace\")\n    print(module_data)\n    return module_data\n\ndef get_formatted_module_data(module_data:pd.DataFrame):\n    \"\"\"Reformat the loaded dataframe containing module data into lists of required elements\n\n    Args:\n        module_data (pd.DataFrame): The loaded module data from a spreadsheet file\n\n    Returns:\n        (list[Module], list[str], list[str], set, set): A list of loaded \n        modules, a list of module group names, a list of semester IDs, a \n        set containing the IDs of any required modules not found in the \n        loaded modules list, a set containing the IDs of any mutually \n        excluded modules not found in the loaded modules list\n    \"\"\"\n    # Keep track of any module IDs listed in the requirements or mutual exclusions but not found among the given modules\n    required_modules_not_found = set()\n    mutually_excluded_modules_not_found = set()\n\n    # Create the module objects\n    loaded_modules:dict[str, Module] = dict()\n    for _, r in module_data.iterrows():\n        m = Module(r.module_id, r.module_name, r.credits, r.semester, r.module_group, r.capacity, r.available_spaces, [], [])\n        loaded_modules[r.module_id] = m\n\n    # Add mutual exclusion and requirement references between the module objects\n    for _, r in module_data.iterrows():    \n        if not pd.isna(r.mutually_excluded_modules):\n            mutually_excluded_module_ids = [str(s).strip() for s in r.mutually_excluded_modules.split(\",\") if len(str(s).strip()) > 0]\n            for m in mutually_excluded_module_ids:\n                if m in loaded_modules.keys():  \n                    loaded_modules[r.module_id].add_mutual_exclusions([loaded_modules[m]])\n                else:\n                    mutually_excluded_modules_not_found.add(m)\n\n        if not pd.isna(r.required_modules):\n            required_module_ids = [str(s).strip() for s in r.required_modules.split(\",\") if len(str(s).strip()) > 0]\n            for m in required_module_ids:\n                if m in loaded_modules.keys(): \n                    loaded_modules[r.module_id].add_requirements([loaded_modules[m]])\n                else:\n                    required_modules_not_found.add(m)\n\n    return list(loaded_modules.values()), list(module_data.module_group.unique()), list(module_data.semester.unique()), required_modules_not_found, mutually_excluded_modules_not_found\n\n\ndef validate_module_rankings_data(data:pd.DataFrame):\n    errors = []\n    required_columns = [\"student_name\", \"student_id\"]\n    for c in required_columns:\n        if not c in data.columns:\n            errors += [f\"Column '{c}' was not found in the module data file\"]\n    \n    if (\"student_id\" in data.columns) and (\"student_name\" in data.columns):        \n            for name in data.loc[(data['student_id'] == '') | pd.isna(data[\"student_id\"]), 'student_name']:\n                errors += [f\"Student {name} has no listed student ID\"]\n            \n            duplicate_ids = data[data.duplicated('student_id')]['student_id'].unique()\n            if (len(duplicate_ids) > 0):\n                errors += [f\"Student ID '{s_id}' is used more than once in the Rankings file\" for s_id in duplicate_ids]\n                \n    errors += get_replacement_character_error_messages(data)\n\n    return errors \n\ndef validate_module_group_preferences_data(data:pd.DataFrame):\n    errors = []\n    required_columns = [\"student_name\", \"student_id\"]\n    for c in required_columns:\n        if not c in data.columns:\n            errors += [f\"Column '{c}' was not found in the module data file\"]\n    \n    if (\"student_id\" in data.columns) and (\"student_name\" in data.columns):        \n            for name in data.loc[(data['student_id'] == '') | pd.isna(data[\"student_id\"]), 'student_name']:\n                errors += [f\"Student {name} has no listed student ID\"]\n\n    duplicate_ids = data[data.duplicated('student_id')]['student_id'].unique()\n    if (len(duplicate_ids) > 0):\n        errors += [f\"Student ID '{s_id}' is used more than once in the Group Preferences file\" for s_id in duplicate_ids]\n                \n\n    errors += get_replacement_character_error_messages(data)\n\n    return errors \n\n\n\n\ndef load_module_rankings_data(module_preference_data_filepath:Path):\n    return pd.read_csv(module_preference_data_filepath, encoding=\"utf-8\", encoding_errors=\"replace\")\n\ndef load_module_group_preferences_data(module_group_preference_data_filepath:Path):\n    return pd.read_csv(module_group_preference_data_filepath, encoding=\"utf-8\", encoding_errors=\"replace\")\n\n\n\ndef check_ranking_and_group_ids_match(module_rankings_data:pd.DataFrame, module_group_preference_data:pd.DataFrame):\n    def find_non_matched_ids(dataframe1:pd.DataFrame, dataframe2:pd.DataFrame):\n        ids_in_dataframe1 = set([str(s) for s in dataframe1['student_id']])\n        ids_in_dataframe2 = set([str(s) for s in dataframe2['student_id']])\n        missing_from_2 = ids_in_dataframe1 - ids_in_dataframe2\n        missing_from_1 = ids_in_dataframe2 - ids_in_dataframe1\n        return missing_from_1, missing_from_2\n\n    m1, m2 = find_non_matched_ids(module_rankings_data, module_group_preference_data)\n\n    return m1, m2\n\ndef check_sufficient_module_spaces(module_metadata:pd.DataFrame, module_group_preference_data:pd.DataFrame):\n    results = []\n    for group_id in module_metadata[\"module_group\"].unique():\n        total_requested_spaces = module_group_preference_data[group_id].sum()\n        total_available_spaces = module_metadata[module_metadata[\"module_group\"] == group_id][\"capacity\"].sum()\n        results += [(group_id, total_requested_spaces, total_available_spaces)]\n    return results\n\ndef load_students(module_rankings_data:pd.DataFrame, module_group_preference_data:pd.DataFrame, modules:list[Module]):\n    \"\"\"Load the student preferences data from two csv files\n\n    Args:\n        module_preference_data_filepath (Path): Path to the csv file containing module preference rankings\n        module_group_preference_data_filepath (Path): Path to the csv file containing preferred numbers of modules per group\n        modules (list[Module]): List of Module objects\n\n    Returns:\n        (list[Student], list[Student], list[Student], list[str]): A list of loaded Student objects, a list of students who did \n        not rank every module, a list of students with missing IDs, a list of module IDs not ranked by the students\n    \"\"\"\n      \n\n    loaded_student_module_group_preferences:dict[str, dict[str, int]] = dict()\n    loaded_students:dict[str, Student] = dict()\n\n    def student_to_uid(r):\n        n = str(r.student_name).lower().strip().replace(\" \", \"\")\n        i = str(r.student_id).strip().replace(\" \", \"\")\n        if not pd.isna(r.student_id):\n            return f\"{n}_{i}\"\n        else:\n            return f\"{n}_\"\n\n    # Keep track of any students who don't have rankings for all modules\n    students_missing_ranks = []\n    students_missing_ids = []\n\n    # Get the group preferences for each student\n    group_names = [col for col in module_group_preference_data.columns if col not in [\"student_name\", \"student_id\"]]\n    for _, r in module_group_preference_data.iterrows():\n        loaded_student_module_group_preferences[student_to_uid(r)] = dict(zip(group_names, [r[g] for g in group_names]))\n\n    # Create the Student objects, containing module group preferences and within group ranks\n    for _, r in module_rankings_data.iterrows():\n        student_uid = student_to_uid(r)\n\n        # Check if the student has a ranking value for every module\n        all_modules_are_ranked = np.all([not pd.isna(r[m.module_id]) for m in modules if m.module_id in r.index])\n        \n        # Get the module-to-rank dictionary for this student\n        module_rankings = dict(zip([m.module_id for m in modules if m.module_id in r.index], [(r[m.module_id] if not pd.isna(r[m.module_id]) else np.inf) for m in modules if m.module_id in r.index]))\n\n        # Get the list of excluded modules for this student\n        excluded_modules = [m.module_id for m in modules if m.module_id in r.excluded_modules] if not pd.isna(r.excluded_modules) else []\n\n        # Create the Student object to contain this student's data\n        student_id = r.student_id\n        if pd.isna(r.student_id):\n            students_missing_ids.append(r.student_name)\n            student_id = r.student_name\n        s = Student(r.student_name, str(student_id).strip(), loaded_student_module_group_preferences[student_uid], module_rankings, excluded_modules)\n        loaded_students[student_uid] = s        \n\n        if not all_modules_are_ranked:\n            students_missing_ranks.append(r.student_id)\n\n    # List of modules not ranked by the students\n    missing_modules = [m.module_id for m in modules if m.module_id not in module_rankings_data.columns]\n\n    return list(loaded_students.values()), students_missing_ranks, students_missing_ids, missing_modules\n\ndef load_module_assignments(module_assignments_data_filepath:Path):\n    module_assignments_data = pd.read_csv(module_assignments_data_filepath, encoding=\"utf-8\", encoding_errors=\"replace\")\n    return module_assignments_data\n\ndef validate_module_assignments_data(data:pd.DataFrame):\n    errors = []\n    required_columns = [\"student_name\", \"student_id\"]\n    for c in required_columns:\n        if not c in data.columns:\n            errors += [f\"Column '{c}' was not found in the module data file\"]\n    \n    if (\"student_id\" in data.columns) and (\"student_name\" in data.columns):        \n            for name in data.loc[(data['student_id'] == '') | pd.isna(data[\"student_id\"]), 'student_name']:\n                errors += [f\"Student {name} has no listed student ID\"]\n\n    errors += get_replacement_character_error_messages(data)\n    \n    return errors ", "type": "text"}, {"name": "styles.css", "content": ".upload-button {\n  align-items: center;\n  text-align: center;\n  justify-content: center;\n  border-style: solid;\n  border-color: #e9ebec;\n  border-width: 2px;\n  border-radius: 20px;\n  width: 100%;\n  height: 100%;\n}\n\n.file-upload-input-group {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 1px;\n  margin: 1px;\n  min-height: 100px\n}\n\n.shiny-file-input-active {\n  border-color: transparent;\n  box-shadow: none;\n}\n\n.shiny-file-input-over {\n  border-color: transparent;\n  box-shadow: none;\n}\n\n.shiny-file-input-active.shiny-file-input-over .upload-button {\n  border-color: #848f99;\n  border-style: solid;\n}\n\n.upload-button:hover {\n  border-color: #848f99;\n  border-style: solid;\n}\n\n.progress {\n  height: 32px;\n}\n\n.progress .progress-bar {\n  font-size: 16px;\n  line-height: 28px;\n}\n\n.input-group-btn {\n  width: 100%;\n}\n\n.input-group {\n  width: 100%;\n  flex-grow: 4;\n}\n\n.upload_icon {\n  display: inline-block;\n  font-size: 32px;\n  width: 32px;\n  height: 32px;\n  margin: 32px;\n}", "type": "text"}]